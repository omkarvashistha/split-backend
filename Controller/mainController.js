const {Groups,Users,Transactions,userGroupMapping,firestore} = require('../model/Schema');
const helper  = require('../utilities/helper');

/**
 * 
 Status Code :{
    100 : "success",
    101 : "failed",
    102 : "user already exists",
 } 
 */

/*****************User APIs***************** */

exports.createUser = async(req,res) => {
    try {
        const username = req.body.username;
        const email = req.body.email;
        const password = req.body.password;

        if(await helper.userExists(email)){
            console.log("here");
            res.json({
                code : 102
            })
            return;
        }
        
        const userRef = Users.doc();
        const userId = userRef.id;
        console.log(userId);
        if(userId === -1){
            console.log('Error in getting user id');
            res.json({
                code : 101
            });
            return;
        }

        const userDataObj = {
            UId : userId,
            UName : username,
            email : email,
            password : password
        }

        await Users.add(userDataObj).then((result)=>{
            res.json({
                code : 100
            });
        }).catch((err)=>{
            console.log('Error while adding data' , err);
            res.json({
                code : 101
            });
        });
        return;
        
    } catch (error) {
        console.log(error);
        res.json({
            error : "Not created"
        });
        return;
    }
}

exports.login = async(req,res) => {
    try {
        const userData = req.body;
        const userCheckResponse = await helper.checkUserCredentials(userData.email,userData.password);

        if(userCheckResponse){
            res.json({
                code : 100
            })
        } else {
            res.json({
                code : 101
            })
        }
        return;
    } catch (error) {
        res.json({
            error : error
        })
        return;
    }
}

exports.getNameFromId = async(req,res) => {
    try {
        const name = await helper.getUserNameFromId(req.body.UId);
        if(name){
            return res.status(200).json({
                code : 100,
                UName : name
            });
        }
        res.status(201).json({
            code : 101,
            UName : name
        })
    } catch (error) {
        res.json(404).json({
            code : 102
        })
    }
}

exports.getFriends = async (req, res) => {
    const { email } = req.body;
    if (!email) {
        return res.status(400).send({ error: 'UId is required in the request body.' });
    }

    try {
        const UId = await helper.getUserIdFromEmail(email);
        const doc = await Users.where('UId','==',UId).get();
        console.log(`User fetch attempt for ${UId} found: ${doc.empty}`);
        
        if (doc.empty) {
            return res.status(404).send({ error: 'User not found.' });
        }

        const userDataRef = doc.docs[0];
        const friends = userDataRef.data().friends;
        console.log("friends ->",friends);
        if (!friends || !Array.isArray(friends) || friends.length === 0) {
            console.log("here");
            return res.status(201).send({code : 100 , friends : [] });
        }

        // Fetch each friend's UName
        const friendsData = await Promise.all(friends.map(async (friendUId) => {
            const friendDoc = await Users.doc(friendUId).get();
            if (friendDoc.exists) {
                return { UId: friendUId, UName: friendDoc.data().UName || 'No name available' };
            }
            return { UId: friendUId, UName: 'User not found' }; // Handling missing users
            }  
        ));
        console.log(friendsData);
        res.status(200).json({code : 100 , friends : friendsData});
    } catch (error) {
        console.error('Error fetching friends:', error);
        res.status(404).send({ error: 'Internal server error' });
    }
}

exports.addFriend = async (req, res) => {
    const { email, FName } = req.body;
    console.log(email,FName);

    const UId = await helper.getUserIdFromEmail(email);
  
    if (!UId || !FName) {
      return res.status(201).send({ code : 101, message: 'Both UId and FId are required in the request body.' });
    }
  
    try {
      // Reference to the user's document
        const querySnapshot = await Users.where('UId', '==', UId).get();

        if (querySnapshot.empty) {
            return res.status(201).send({ code : 101 , message : "User not found" });
        }

        const userDocRef = querySnapshot.docs[0].ref;

      // Create a new user for the friend
        const newFriendRef = Users.doc();
        const FId = newFriendRef.id; // Get the unique ID generated by Firestore for the new friend document

        await newFriendRef.set({
            UId: FId,  // Store the unique ID explicitly if needed
            UName: FName,
            friends: [UId],  // Initialize the friends array with UId
            temporary: true  // Mark the friend document as temporary
        });
  
      // Get current friends array, or initialize if it doesn't exist
      const userData = (await userDocRef.get()).data();
      let friends = userData.friends || [];
  
      // Check if FId is already in the friends array to avoid duplication
      if (!friends.includes(FId)) {
        friends.push(FId);
  
        // Update the user's document with the new array
        await userDocRef.update({ friends });
  
        res.status(200).json({ code: 100});
      } else {
        res.status(200).json({ code: 101});
      }
    } catch (error) {
      console.error('Error adding friend:', error);
      res.status(500).send({ error: 'Internal server error' });
    }
};
  

/*****************Group APIs**************** */

exports.addGroup = async(req,res) => {
    try {
        const {email,GName} = req.body;
        const UserId = await helper.getUserIdFromEmail(email);

        if(!UserId) return res.json(400).status({code  : 101});

        const groupRef = Groups.doc();
        const GId = groupRef.id;
        const GroupMembers = [UserId];
        const createdOn = helper.getFullDate();

        const groupData = {
            GId : GId,
            GName : GName,
            GroupOwner : UserId,
            GroupMembers : GroupMembers,
            CreatedOn : createdOn
        }

        const GroupAddingRes = await Groups.add(groupData);

        if(!GroupAddingRes){
            res.status(201).json({
                code : "101"
            });
            return;
        }
        const groupUserRef = userGroupMapping.doc();
        const GUMId = groupUserRef.id;
        const GIds = [GId];
        const GroupUserMappingData = {
            GUMId : GUMId,
            UId : UserId,
            GIds : GIds
        };
        
        const GroupUserMappingRes = await userGroupMapping.add(GroupUserMappingData);

        if(!GroupUserMappingRes){
            res.status(201).json({
                code : "101"
            });
            return;
        }

        res.status(200).json({
            code : "100"
        });
    } catch (error) {
        console.log(error);
        res.json({
            error : error.message
        })
    }
}

exports.getGroups = async(req,res) => {
    try {
        const email = req.params.email;
        console.log("inside");
        const UId = await helper.getUserIdFromEmail(email);

        var groups = [];
        const querySnapshot = await userGroupMapping.where("UId","==",UId).get();
        querySnapshot.docs.forEach(element => {
            element && groups.push(element.data().GIds[0]);
        });

        console.log(groups);
        var groupsData = [];

        for(let i=0;i<groups.length;i++){
            const GId = groups[i];
            const groupData = await helper.getGroupDataFromId(GId);
            groupsData.push(groupData);
        }

        res.status(200).json({
            code : 100,
            groupsData : groupsData
        });

    } catch (error) {
        throw error;
    }
}


/*********************Transaction APIs********************* */

exports.addTransaction = async(req,res) => {
    try{
        let { amount, users, paidBy, GId, title } = req.body; // Extract GId from the request
        console.log(req.body);
        const date = await helper.getFullDate(); // Get the current date in the desired format
        const paidById  = await helper.getUserIdFromEmail(paidBy);

        // Convert amount to a number if it's a valid numeric string
        amount = typeof amount === 'string' ? parseFloat(amount) : amount;

        // Data validation
        if (typeof amount !== 'number' || !Array.isArray(users) || !paidBy || !GId) {
            return res.status(400).json({ error: 'Invalid data format' });
        }

        // Create and set transaction in the Transactions collection
        const transactionRef = Transactions.doc();
        const TId = transactionRef.id;
        await transactionRef.set({
            TId,
            title,
            amount,
            users,
            paidById,
            date
        });

        // Update the Groups collection with the new transaction ID
        let transactionComplete = false;
        await firestore.runTransaction(async (transaction) => {
            const groupQuerySnapshot = await transaction.get(Groups.where('GId', '==', GId));
            if (groupQuerySnapshot.empty) {
                console.log(`No group found with GId ${GId}.`);
                transactionComplete = false;
            } else {
                const groupDoc = groupQuerySnapshot.docs[0];
                const groupData = groupDoc.data();
                const groupMembers = groupData.GroupMembers || [];
                const transactionUsers = users.map(user => user.userId);

                // Check for new group members in transaction users and add them
                let updateNeeded = false;
                users.forEach(userObject => {
                    let userId = Object.keys(userObject)[0]; // Accessing the UserId property from the object
                    console.log("userId ->", userId);

                    if (!groupMembers.includes(userId)) {
                        groupMembers.push(userId);
                        updateNeeded = true;
                    }
                });

                if (updateNeeded) {
                    transaction.update(groupDoc.ref, { GroupMembers: groupMembers });
                }

                const transactions = groupData.transactions || [];
                transactions.push(TId);
                transaction.update(groupDoc.ref, { transactions });
                transactionComplete = true;
            }
        });

        if (!transactionComplete) {
            // If transaction did not complete, return a specific code
            console.log('Transaction not completed. Group document was not updated.');
            return res.status(201).json({ code: 101 });
        }

        // If everything is successful, return a success code
        return res.status(200).json({ code: 100 });

    } catch (err) {
        console.log(err);
        res.json({
            error : err
        })
    }
}

exports.getTransactionForGroup = async (req, res) => {
    try {
        const { GId, UId } = req.body;

        // Validate GId and UId
        if (!GId || !UId) {
            return res.status(400).json({ error: 'GId and UId are required.' });
        }

        // Query the Groups collection for the document with the matching GId
        const groupQuerySnapshot = await Groups.where('GId', '==', GId).get();

        if (groupQuerySnapshot.empty) {
            return res.status(404).json({ error: 'Group not found.' });
        }

        // Assuming GId is unique and only one document should match
        const groupDoc = groupQuerySnapshot.docs[0];
        const transactionIds = groupDoc.data().transactions || [];
        const finalList = new Map();
        console.log("Transaction IDs: ", transactionIds);
        // Iterate over each transaction ID to process transaction data
        for (const transactionId of transactionIds) {
            console.log("Processing transactionId -> ", transactionId);
            const transactionRef = Transactions.doc(transactionId);
            const transactionDoc = await transactionRef.get();
            
            if (transactionDoc.exists) {
                
                const transactionData = transactionDoc.data();
                const users = transactionData.users;
                const paidBy = transactionData.paidBy;
                console.log(`Transaction ${transactionId} Users:`, users);
                
                if(paidBy === UId) {
                    users.forEach(user => {
                        const key = Object.keys(user)[0];
                        const value = user[key];
                        if(key !== UId){
                            if(finalList.has(key)) {
                                finalList.set(key, finalList.get(key) + value);
                            } else {
                                finalList.set(key, value);
                            }
                        }
                    });
                } else {
                    users.forEach(user => {
                        const key = Object.keys(user)[0];
                        const value = user[key];
                        if(key == UId) {
                            if(finalList.has(paidBy)){
                                finalList.set(paidBy, finalList.get(paidBy) - value);
                            } else {
                                finalList.set(paidBy,-value);
                            }
                            //console.log("Not paid ->",finalList.get(key));
                        }

                    });
                }
                console.log("Here ->");
            } else {
                console.log(`Transaction document ${transactionId} does not exist.`);
            }  
        }
        
        const finalListObject = Object.fromEntries(finalList);
        console.log(finalListObject);
        if(finalList.size === 0){
            return res.status(201).json({
                code : 101,
                finalList : finalListObject
            });
        } else {
            return res.status(200).json({
                code : 100,
                finalList : finalListObject
            });
        }
    } catch (err) {
        console.error('Error while fetching transactions:', err);
        return res.status(500).json({ error: 'Internal server error' });
    }
};


exports.invalid = async(req,res,next)=>{
    const err = new Error();
    err.message = 'Invalid Route';
    err.status = 404;
    next(err);
}